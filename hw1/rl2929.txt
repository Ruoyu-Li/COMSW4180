Ruoyu Li

1. CTR is better. Because CTR's encryption and decryption are parallelizable, which can accelerate the process, but CBC's encryption is sequential. Also, transmission errors in CTR only effect the wrong bits and nothing more, which is important to streaming data transmission.

2. Yes. If we find that the first block of C1 is the same as the first block of C2, it indicates that the first block of P1 is the same as the first block of P2.

3. Yes. If the size of the first file is integral multiple of the block cipher size, which means padding is not needed for the first file, and two files are encrypted sequentially, which means the couter is sequential, the spliced cipher can be succuessfully decrypted.

4. Because a standard block cipher has defended the security of one block's data. When it comes to stream data, not only security but also efficiency, parallelizability, stream data's pattern, etc, should be taken into consideration based on different requirements and machine's architecture. So it's not necessary to have a standard stream cipher.

5. a. Suppose Alice chose a key K already. She can use Bob's public key Bpub to encrypt K and send it to Bob. Bob can use his private key Bpriv to decrypt it and get K.

b. Alice firstly uses K and block cipher B to encrypt the file and uses hash function H to calculate the hash value of the file. Then she uses X and her private key Apriv to encrypt the hash value of the file as the signature, and concatenate these two parts into a message. Finally, she sends this message to Bob.

c. Bob firstly splits the message into two parts. He decrypts the first part with block cipher key K to get the file. He verifies the signature with Alice's public key Apub. Then he uses the hash function H to calculate the hash value of the file. If the hash value equals the value of the verified (decrypted by public key) signature, then verification succeeds; if not, then verification fails.

6. Because this protocol is based on the Decisional Diffie-Hellman assumption, which means that in a cyclic group, given g^a, g^b, g^ab or g^a, g^b, g^t(t is a uniformly randomly chosen number), one attacker can't distinguish between g^ab and random number g^t in polynomial time. And DDH assumption holds the Computational Diffie-Hellman assumption, which means that the attacker cannot compute the g^ab in polynomial time. Therefore, even though Ta and Tb are sent in the clear, and one attacker can see them, he cannot compute out their shared key.

7. Ability to run on today's computers is for usability and compatibility for now. Because today's cryptography algorithms mostly are based on some difficult mathematics problems, such as discrete log and factorization. But quantum computation can break them in a polynomial time, such as Shor's algorithm, which means some cryptography standards will be insecure. So it is necessary to develop new standards.

8. It is for defending some side-channel attacks. Otherwise, attackers can try different queries on an encryption machine and analyze the time that it takes and some information of the key could leak.

9. Trivium:
The scheme has two phases: key and IV setup, keystream generation. There is a 288-bit internal state. We denote each as s1, s2 s3, ..., s288. For each round, the state will be updated by rotation, and we use 15 specific state bits to update 3 bits of the state and to compute 1 bit of keystream until we generate all N bits of keystream. The 15 specific bits are s66, s91, s92, s93, s171, s162, s175, s176, s177, s264, s243, s286, s287, s288, s69.
In key and IV setup phase, firstly we have an 80-bit key and an 80-bit IV. We initialize the state bits. S1 to s80 are loaded by 80-bit key; s94 to s174 are loaded by 80-bit IV; other bits are all assigned 0 except the last three bits: s286, s287, s288 are assigned 1. Next, the state will be rotated for 4 cycles. Each bit is rotated to right by 1 bit, except three bits are updated as follow:
t1 ← s66 +s91 ·s92 +s93 +s171
t2 ←s162 +s175 ·s176 +s177 +s264
t3 ←s243 +s286 ·s287 +s288 +s69 
(s1,s2,...,s93) ← (t3,s1,...,s92) 
(s94,s95,...,s177) ← (t1,s94,...,s176) 
(s178,s279,...,s288) ← (t2,s178,...,s287)
In key stream generation phase, it is similiar to the second part of key and IV setup phase. We not only rotated the state and update 3 bits of it in each round, but generate 1 bit of key stream. The bit of key stream generated by each round is:
t1 ← s66 + s93
t2 ← s162 + s177 
t3 ← s243 + s288 
zi ← t1 + t2 + t3
So after N rounds, we can generate a key stream of N bits.

